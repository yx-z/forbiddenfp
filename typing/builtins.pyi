class object:  # don't need to copy this line. only append content below to the end of your IDE's stubbed `object` class.
    import builtins
    from numbers import Number
    from typing import Callable, List, NoReturn, Optional, Dict, TypeVar, Iterable, Sequence, Tuple, Union, Set, Type, \
        ContextManager, Any
    from typing_extensions import ParamSpec, Self

    _P = ParamSpec("_P")
    _R = TypeVar("_R")
    _F = Callable[[_P], _R]
    _Pred = Callable[[_P], bool]
    _P2 = ParamSpec("_P2")
    _R2 = TypeVar("_R2")
    _F2 = Callable[[_P2], _R2]
    _ExceptionType = Type[Exception]
    _ExceptionOrExceptionFunc = Union[_ExceptionType, Callable[[_P], _ExceptionType]]

    def greater_than(self: Self, val: _P) -> bool: ...

    def less_than(self: Self, val: _P) -> bool: ...

    def greater_than_or_equals(self: Self, val: _P) -> bool: ...

    def less_than_or_equals(self: Self, val: _P) -> bool: ...

    def negate_val(self: Self) -> _P: ...

    def negate(self: Self) -> _Pred: ...

    def equals(self: Self) -> bool: ...

    def not_equals(self: Self) -> bool: ...

    def contains(self: Self) -> bool: ...

    def not_contains(self: Self) -> bool: ...

    def truthful(self: Self) -> bool: ...

    def falseful(self: Self) -> bool: ...

    def in_iter(self: Self) -> bool: ...

    def not_in(self: Self) -> bool: ...

    def asserting(self: Self) -> Self: ...

    def is_none(self: Self) -> bool: ...

    def is_not_none(self: Self) -> bool: ...

    def add(self: Self, val: _P) -> _R: ...

    def subtract(self: Self, val: _P) -> _R: ...

    def multiply(self: Self, val: _P) -> _R: ...

    def divide(self: Self, val: _P) -> _R: ...

    def and_val(self: Self, val: _P) -> _R: ...

    def and_func(self: Self, val: _Pred) -> _Pred: ...

    def or_val(self: Self, val: _P) -> _R: ...

    def or_func(self: Self, val: _Pred) -> _Pred: ...

    def map_val(self: Self,
                vals: Optional[Dict[_P, _R]] = None,
                default: Optional[_R] = None, **kwargs: _R) -> Optional[_R]: ...

    def map_pred(self: Self, pred_to_val: Dict[_Pred, _R],
                 default: Optional[_R] = None) -> Optional[_R]: ...

    def match_val(self: Self,
                  val_to_action: Optional[Dict[_P, _F]] = None,
                  default: Callable[[_P], Optional[_R]] = use(None), **kwargs: _F) -> Optional[_R]: ...

    def match_pred(self: Self, pred_to_action: Dict[_Pred, _R], default: _F = use(None)) -> Optional[_R]: ...

    def isinstance(self: Self, t: Type) -> bool: ...

    def call(self: Self, *args: _P.args, **kwargs: _P.kwargs) -> _R: ...

    def compose(self: Self, *funcs: Sequence[Callable[[_P], _R]]) -> _F2: ...

    def compose_r(self: Self, *funcs: Sequence[Callable[[_P], _R]]) -> _F2: ...

    def flatten(self: Self, recurse: bool = False) -> Iterable: ...

    def partial(self: Self, *args: _P.args, **kwargs: _P.kwargs) -> _F: ...

    def apply(self: Self, func: _F) -> Self: ...

    def print(self: Self, print_func: _F = print) -> Self: ...

    def print_list(self: Self) -> Self: ...

    def pair(self: Self, val: _P2) -> Tuple[Self, _P2]: ...

    def pair_func(self: Self, func: _F) -> Tuple[Self, _R]: ...

    def groupwise(self: Self, n: int) -> Iterable[Tuple[_P, ...]]: ...

    def split_at(self: Self, pred: _Pred) -> Iterable[Tuple[_P, ...]]: ...

    def batch(self: Self, n: int) -> Iterable[Tuple[_P, ...]]: ...

    def i_th(self: Self, i: int) -> _P: ...

    def pairwise(self: Self) -> Iterable[Tuple[_P, _P]]: ...

    def also(self: Self, _: _R) -> Self: ...

    def dir(self: Self) -> List[str]: ...

    def vars(self: Self) -> Dict[str, Any]: ...

    def then(self: Self, func: _F) -> _R: ...

    def then_use(self: Self, val: _R) -> _R: ...

    def getattr(self: Self, name: str) -> _R: ...

    def getitem(self: Self, key: _P2) -> _R: ...

    def setattr(self: Self, **kwargs: _P.kwargs) -> Self: ...

    def setitem(self: Self, key: _P2, val: _R) -> Self: ...

    def apply_unpack(self: Self, func: _F) -> Self: ...

    def then_unpack(self: Self, func: _F) -> _R: ...

    def empty(self: Self) -> bool: ...

    def tee(self: Self, n: int = 2) -> Tuple[Self, ...]: ...

    identity = lambda x: x

    def min(self: Self, default: Optional[_P] = None, key: _F = identity) -> Optional[_P]: ...

    def max(self: Self, default: Optional[_P] = None, key: _F = identity) -> Optional[_P]: ...

    def range(self: Self, start: Optional[int] = None, step: Optional[int] = None) -> Iterable[int]: ...

    truthful = bool

    def all(self: Self, predicate: _Pred = truthful) -> bool: ...

    def any(self: Self, predicate: _Pred = truthful) -> bool: ...

    def map(self: Self, func: _F, *other: Iterable[_P2]) -> Iterable[_R]: ...

    def map_dict(self: Self,
                 key_func: _F = identity,
                 val_func: _F2 = identity) -> Iterable[Tuple[_R, _R2]]: ...

    def filter_unpacked(self: Self, predicate: Callable[[_P.args], bool] = truthful) -> Iterable[Iterable[_P]]: ...

    def filter(self: Self, predicate: _Pred = truthful) -> Iterable[_P]: ...

    def filter_key(self: Self, predicate: Callable[[_P], bool]) -> Iterable[Tuple[_P, _P2]]: ...

    def filter_val(self: Self, predicate: Callable[[_P2], bool]) -> Iterable[Tuple[_P, _P2]]: ...

    use = lambda x: lambda *args, **kwargs: x

    def last(self: Self, predicate: _Pred = use(True)) -> Optional[_P]: ...

    def next(self: Self, predicate: _Pred = use(True)) -> Optional[_P]: ...

    def sum(self: Self, of: Callable[[_P], Number] = identity, predicate: _Pred = truthful) -> int: ...

    def len(self: Self, predicate: _Pred = use(True)) -> int: ...

    def reversed_iter(self: Self) -> Sequence[_P]: ...

    def sorted_iter(self: Self, key: _F = identity, reverse: bool = False) -> List[_P]: ...

    _initial = object()

    def reduce(self: Self, func: Callable[[_P, _P], _R], initial: _P2 = _initial) -> _R: ...

    def reduce_r(self: Self, func: Callable[[_P, _P], _R], initial: _P2 = _initial) -> _R: ...

    def partition(self: Self, predicate: _Pred = truthful) -> Tuple[Iterable[_P], Iterable[_P]]: ...

    def counter(self: Self) -> Dict[_P, int]: ...

    def groupby(self: Self, key: _F) -> Iterable[Tuple[_R, Iterable[_P]]]: ...

    def chain(self: Self, *rem: Iterable[Iterable[_P]]) -> Iterable[_P]: ...

    def zip(self: Self, *rem: Iterable[_P]) -> Iterable[Tuple[_P, ...]]: ...

    def enumerate(self: Self) -> Iterable[Tuple[int, _P]]: ...

    def tuple(self: Iterable[_P]) -> Tuple[_P, ...]: ...

    def set(self: Iterable[_P]) -> Set[_P]: ...

    def list(self: Iterable[_P]) -> List[_P]: ...

    def dict(self: Self) -> Dict[_P, _P2]: ...

    def join(self: Self, sep: str = "", to_str: Callable[[_P], str] = str) -> str: ...

    def starmap(self: Self, func: Callable[[_P.args], _R]) -> Iterable[_R]: ...

    def each_also(self: Self, func: Callable[[Iterable[_P]], _R]) -> Sequence[Sequence[_P]]: ...

    def each_also_unpacked(self: Self, func: Callable[[_P.args], _R]) -> Sequence[Sequence[_P]]: ...

    def each(self: Self, func: Callable[[Iterable[_P]], _R]) -> None: ...

    def each_unpacked(self: Self, func: Callable[[_P.args], _R]) -> None: ...

    def accumulate(self: Self,
                   func: Callable[[_R, _P], _R] = lambda x, y: x + y,
                   initial: _P2 = _initial) -> Iterable[_R]: ...

    def pairwise(self: Self) -> Iterable[Tuple[_P, _P]]: ...

    def product(self: Self, repeat: int = 1) -> Iterable[Tuple[_P, ...]]: ...

    def repeat(self: Self, times: Optional[int] = None) -> Iterable[_P]: ...

    def infinite(self: Self) -> Iterable[Self]: ...

    def cycle(self: Self) -> Iterable[Self]: ...

    def takewhile(self: Self, predicate: _Pred = truthful) -> Iterable[_P]: ...

    def islice_up_to(self: Self, stop: int, predicate: _Pred = use(True)) -> Iterable[_P]: ...

    def islice(
            self: Self, start: int, stop: Optional[int], step: int = 1, predicate: _Pred = use(True)
    ) -> Iterable[_P]: ...

    def dropwhile(self: Self, predicate: _Pred = truthful) -> Iterable[_P]: ...

    def float(self: Self) -> float: ...

    def int(self: Self) -> int: ...

    def str(self: Self) -> str: ...

    def repr(self: Self) -> str: ...

    def format(self: Self, format_str: str) -> str: ...

    def if_branches(self: Self, true_func: _F, false_func: _F, predicate: _Pred = truthful) -> _R: ...

    def if_true(self: Self, func: _F, predicate: _Pred = truthful) -> Optional[_R]: ...

    def apply_if_branches(self: Self, true_func: _F, false_func: _F, predicate: _Pred = truthful) -> _P: ...

    def apply_if_true(self: Self, func: _F, predicate: _Pred = truthful) -> _P: ...

    def or_else(self: Self, val: _R, predicate: _Pred = truthful) -> _R: ...

    def or_eval(self: Self, func: _F, predicate: _Pred = truthful) -> _R: ...

    def or_raise(self: Self, val_or_func: _ExceptionOrExceptionFunc, predicate: _Pred = truthful) -> _P: ...

    def raise_as(self: Self, val_or_func: _ExceptionOrExceptionFunc) -> NoReturn: ...

    def then_suppressed(
            self: Self, func: _F, exception_type: _ExceptionType = Exception, on_except: Optional[_R] = None
    ) -> Optional[_R]: ...

    def apply_suppressed(self: Self, func: _F, exception_type: _ExceptionType = Exception) -> _P: ...

    def then_catch(self: Self, func: _F, exception_type: _ExceptionType = Exception,
                   exception_handler: Callable[[_P, _ExceptionType], _R2] = use(None)) -> Union[_R, _R2]: ...

    def apply_catch(self: Self, func: _F, exception_type: _ExceptionType = Exception,
                    exception_handler: Optional[Callable[[_P, _ExceptionType], _R2]] = None) -> _P: ...

    def apply_while(self: Self, func: Callable[[_P], _P], predicate: _Pred = truthful) -> _P: ...

    def yield_while(self: Self, func: Callable[[_P], _P], predicate: _Pred = truthful) -> Iterable[_P]: ...

    def with_context(self: Self, context_func: Callable[[_P], ContextManager],
                     then: Union[Callable[[_P, _R], _R2], Callable[[_P], _R2]]) -> _R2: ...

    def with_open(self: Self,
                  then: Callable[[_P, _R], _R2],
                  open_func: Callable[[_P], _R] = open,
                  mode: builtins.str = "r",
                  *args: _P.args,
                  **kwargs: _P.kwargs) -> _R2: ...

    def take_unpacked(self: Self, func_on_iterable_of_iterable: Callable[
        [Callable[[Iterable[_P]], _R], Iterable[Iterable[_P]]], _R2]) -> Callable[
        [Callable[[_P.args], _R], Iterable[Iterable[_P]]], _R2]: ...
